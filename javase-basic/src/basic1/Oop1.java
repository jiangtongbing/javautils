package basic1;

import basic1.other.A;

public  class Oop1 {
		//1.什么是类？什么是对象？
		//	  1)现实世界是由很多对象组成的
		//	    基于对象抽出了类
		//2)对象:真实存在的单个个体
		//	    类:类型/类别，代表一类个体
		//3)类中可以包含:
		//	    3.1)所有对象所共有的属性/特征----------------成员变量
		//		3.2)所有对象所共有的行为---------------------方法
		//4)一个类可以创建多个对象
		//	    同一类型所创建出来的对象，结构相同，数据不同
		//5)类是对象的模板，对象是类具体的实例
	public static void main(String[] args) {
		 //生成一个对象
		A a=new A();
		//对成员变量直接赋值。
		a.name="xiaoming";
		//调用对象的方法。
		a.setAge(10);
		//直接访问成员变量。
		System.out.println("a.name="+a.name);
		// 访问修饰符 public ,private ,protected,static,final, 不修饰的话，就是normal 
		// public 全局修饰符，可以让你的类，成员变量，方法被本类，以及同包类，甚至是不在一个包内的类 直接调用而不受限制，
		// private 隐私修饰符，顾名思义，被该修饰符修饰的类，成员变量，方法，只能在该类内部被访问。其他类则无法访问。
		// protected 保护修饰符，只在父类与子类之间被访问。
		// normal 则是不用任何修饰符修饰的，它的隐蔽效果和private 几乎相同。
		// final 修饰符，最终修饰符，意味着被该修饰符修饰的成员变量，方法以及类，一旦定义和初始化完毕后，将无法再次改变。
		// 这个概念和静态 的概念不能混淆。
		// 静态修饰符，static。 类是无法被该修饰符修饰的，类要产生对象，意味着动态则与静态背道而驰了。
		// static 可以用于修饰 成员变量，方法，以及代码块。
		// 被static修饰的成员变量，方法，属于类，而不属于某个该类的具体对象。（这点一定要清楚记得）
		// 但是是被 该类所有的具体对象都能访问到 公共资源。
		// 访问静态成员变量和方法时 对象可以像访问其他正常的非静态成员变量和方法一样访问，也可以修改，一旦对其进行了修改，
		// 则其他该类再次访问时 就已经是访问变化过的了。
		// 也可以拿类名 去访问 静态成员变量，方法，比如 A.count
		System.out.println("A.count="+A.count);
		// 最后是 静态代码块，现在只需要理解 它会在类加载之前被执行。这个涉及到JVM的运行原理，暂不讲解。
		// 具体 看 A类里 怎么写来着。
		// 还剩两个修饰符，abstract-虚拟 和interface-接口 ,下面再说。
		// 为什么一定要先讲修饰符，也是为了方便后面讲继承的概念。
	
		// 方法的重载，overload,这个概念和后面，方法的继承是不一样的，此处要注意。
		// 方法的重载  1)发生在一个类中，方法名称必须相同，参数列表必须不同（其实只要是有一个形参的类型不一样就行了）,
		//        2)编译器在编译时会根据方法的签名自动绑定调用的方法
		// 第二个点 是原文的翻译，可能无法立即理解，你可以想象现在有个类A，它有两个方法名相同的方法，但是它的参数列表不同，
		// 那么你这个方法肯定是要被调用的，调用它的首先就是编译器，编译器会检查类是否符合规范和运行该类的方法。
		// 当编译器再一个类内部遇到两个以及以上的方法名相同的方法，回去进行检测它是否符合重载规范，然后调用的时候 ，会根据
		// 调用时 传入的参数的类型去判断调用哪个方法。比如A中有 setAttr(int age,String name) 
		// 和 setAttr(String name,int age) 此处的定义是符合重载规范的，虽然看上去着两个方法非常像，哪怕最后的功能完全相同。
		// 但是就是因为，形参类型的类型问题，使得编译器认为它们两个是两个不一样的方法。
		// 第一个方法的两个形参的类型 按顺序分别是 int和String， 但是第二个为 String 和int ，
		// 这个我会在 -反射-的章节里 给出解释，为什么编译器能识别这两个方法是不一样的方法哦。		
		
		// 构造方法，Constructer。
		// 再系统根据类创建对象时被调用的方法。通常用来做一些对象的初始化操作什么的。
		// 构造方法没有返回值。名字必须与类同名。每一个类默认会有一个无参的构造方法。构造方法也可以被重载。
		
		//关于this ,this 指代当前对象，是对当前对象的引用。
		//这个是书上的说法，很抽象，让我换种说法吧。
		//我和你都是人，我们都有器官是嘴巴，我们都能用嘴巴吃饭，（你在说什么屁话?），年龄未知。 
		//其实这句话已经包含了一个类该有的部分，成员变量和方法。年龄，器官是成员变量，吃饭是方法。
		//我和你都是人这个类的对象。
		//那么好了，现在，我和你被创造出来了，但是 我25岁，你19岁，
		//现在我去吃饭了，或者说调用了我的吃饭方法 ， 那么该方法内部的this应该是对我的引用。
		//通过this 去访问我的成员变量，那你应该是知道 我是有一张嘴巴，我的年龄是25岁。我会吃饭。
		//但是如果此时是你去吃饭了，或者调用了你的吃饭方法， 那么此时的this应该是对你的引用，
		//通过this 去访问到的信息，应该是你有一张嘴巴，你是19岁，你会吃饭。
		//那么好了，最后想到这里，你就会知道， 其实this这个概念只会在 方法内部才能使用。
		//（不过，静态方法内部是不存在this的哦，因为静态方法是类的方法，不是某个具体对象的方法。这就好比，
		// 我说 我吃饭了，你可能不会感到迷惑，但是我说人类吃饭了，你就会立马会问谁吃饭了啊？因为此时的this不唯一确定。也就无法产生了）
		//虽然是同一个类，调用了同一个方法，但是因为对象的不同，从而导致了方法内部this指向的对象是不同的。
		//从而 this 所能访问的 成员变量，甚至是方法  也是不一样的。
		//说完this之后呢，我要说个更广泛的词，叫引用，其实this就是引用的一种,
		//之前我们应该说过变量，其实变量不仅仅是只有基本类型，他也可以是 引用类型，其类型是无限的。
		//所有的引用类型（对象）都会有一个唯一的父类就是Object,
		//基本类型和引用类型是不一样的，8大基本类型都有各自的包装类形成引用类型。
		//关于  赋值
        // 基本类型的赋值 是值赋值，一旦两个相同基本类型变量之间挂了等号，就相当于直接改变被赋值方的值。
		// 引用类型的赋值 是引用赋值，引用类型的变量只存放对象在内存中的地址，所以引用类型的变量之间的赋值，其实只是地址之间的赋值
		//。并不影响对象本身。
		//最后关于 null ，null是空的引用，意味着没有关联内存中的任何一个对象。也就无法对null进行访问，通常对null访问的话，
		//会抛出 java.lang.nullpointer 也就是所谓的 空指针异常。（这里又涉及了C的概念。还是要记得java始终只是C的更高级的实现，底层依旧是C。）
		
		//对下面程序做思考
		A a1=new A("tom",10);
		A a2=a1;
		a2.name="jerry";
		//这里的a1的name 成员变量值是否发生改变。
		System.out.println("a1.name:"+a1.name);
		
 	} 
	
	
}
